<?xml version="1.0"?>
<doc>
    <assembly>
        <name>R5T.F0000</name>
    </assembly>
    <members>
        <member name="T:R5T.F0000.Documentation">
            <summary>
            Common operations on .NET C# built-in types, like characters, strings, integers, etc.
            </summary>
        </member>
        <member name="M:R5T.F0000.ICharacterOperator.Describe(System.Char)">
            <summary>
            Describes a character with its string representation, three-digit numeric value, and name. Example: 'b': 062, "lower-case b".
            </summary>
        </member>
        <member name="M:R5T.F0000.ICharacterOperator.GetCharactersWhere(System.Func{System.Char,System.Boolean})">
            <summary>
            Chooses <see cref="M:R5T.F0000.ICharacterOperator.GetAsciiCharactersWhere(System.Func{System.Char,System.Boolean})"/> as the default.
            </summary>
        </member>
        <member name="M:R5T.F0000.ICharacterOperator.GetIndex(System.Char)">
            <summary>
            Converts the character to its integer index.
            </summary>
        </member>
        <member name="M:R5T.F0000.ICharacterOperator.IsAlphanumeric(System.Char)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Glossary.ForCharacterClasses.Alphanumeric" path="/definition"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.ICharacterOperator.IsCharacter(System.Char)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Glossary.ForCharacterClasses.Character" path="/definition"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.ICharacterOperator.IsControl(System.Char)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Glossary.ForCharacterClasses.Control" path="/definition"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.ICharacterOperator.IsDigit(System.Char)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Glossary.ForCharacterClasses.Digit" path="/definition"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.ICharacterOperator.IsLetter(System.Char)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Glossary.ForCharacterClasses.Letter" path="/definition"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.ICharacterOperator.IsLetterOrDigit(System.Char)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Glossary.ForCharacterClasses.Alphanumeric" path="/definition"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.ICharacterOperator.IsLowercase(System.Char)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Glossary.ForCharacterClasses.Lowercase" path="/definition"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.ICharacterOperator.IsNone(System.Char)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Glossary.ForCharacterClasses.None" path="/definition"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.ICharacterOperator.IsNumber(System.Char)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Glossary.ForCharacterClasses.Number" path="/definition"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.ICharacterOperator.IsPunctuation(System.Char)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Glossary.ForCharacterClasses.Punctuation" path="/definition"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.ICharacterOperator.IsSeparator(System.Char)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Glossary.ForCharacterClasses.Separator" path="/definition"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.ICharacterOperator.IsSymbol(System.Char)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Glossary.ForCharacterClasses.Symbol" path="/definition"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.ICharacterOperator.IsUppercase(System.Char)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Glossary.ForCharacterClasses.Uppercase" path="/definition"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.ICharacterOperator.IsWhitespace(System.Char)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Glossary.ForCharacterClasses.Whitespace" path="/definition"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.ICharacterOperator.ToLower(System.Char)">
            <summary>
            Chooses the invariant lowering operation as default.
            </summary>
        </member>
        <member name="M:R5T.F0000.ICharacterOperator.ToUpper(System.Char)">
            <summary>
            Chooses the invariant uppering operation as default.
            </summary>
        </member>
        <member name="T:R5T.F0000.IExecutablePathOperator">
            <summary>
            
            </summary>
            <remarks>
            Since PathOperator is not available (it is in F0002, not F0000, yet?), some functionality must be postponed to F0002.
            
            Prior work:
            * R5T.Magyar.ExecutableFilePathHelper
            </remarks>
        </member>
        <member name="M:R5T.F0000.IExecutablePathOperator.GetExecutableFilePath_ViaCommandLineArgumentValue">
            <summary>
            Get the current executable's path location from the first argument of the command-line incantation used to start the current process.
            </summary>
        </member>
        <member name="M:R5T.F0000.IExecutablePathOperator.GetExecutableFilePath">
            <summary>
            Gets the path location of the executable via the default method, <see cref="M:R5T.F0000.IExecutablePathOperator.GetExecutableFilePath_ViaCommandLineArgumentValue"/>.
            </summary>
            <remarks>
            There are multiple ways to get the location of the executable, and depending on context (unit test, debugging in Visual Studio, or production) different locations are returned.
            The command line argument is chosen as the default since this is the way the program is actually run by the operating system.
            </remarks>
        </member>
        <member name="M:R5T.F0000.IFileExtensionOperator.GetFileExtensionSeparator">
            <summary>
            Chooses <see cref="M:R5T.F0000.IFileExtensionOperator.GetFileExtensionSeparator_Char"/> as the default.
            </summary>
        </member>
        <member name="T:R5T.F0000.IFileSystemOperator">
            <summary>
            
            </summary>
            <remarks>
            Prior work: R5T.Magyar.
            </remarks>
        </member>
        <member name="M:R5T.F0000.IFileSystemOperator.CreateDirectory_OkIfAlreadyExists(System.String)">
            <summary>
            Creates a directory idempotently (meaning there is no problem with issuing the command multiple times). 
            Note: The system method <see cref="M:System.IO.Directory.CreateDirectory(System.String)"/> does not throw an exception if you create a directory that already exists. However, it's hard to remember this fact. Thus, this method name makes that fact explicit.
            </summary>
        </member>
        <member name="M:R5T.F0000.IFileSystemOperator.DeleteDirectory_Robust(System.String)">
            <summary>
            Deletes a directory path.
            The <see cref="M:System.IO.Directory.Delete(System.String)"/> method throws a <see cref="T:System.IO.DirectoryNotFoundException"/> if attempting to delete a non-existent directory. This is annoying.
            All you really want is the directory to not exist, so this method simply takes care of checking if the directory exists.
            Also annoying, you need to specify the recursive option to delete a directory with anything in it. This method also takes care of specifying true for the recursive option.
            Even more annoying, even after specifying the recursive option, the system method will not delete read-only files. Thus this method disables read-only options on all files recursively.
            </summary>
        </member>
        <member name="M:R5T.F0000.IFileSystemOperator.DisableReadOnly(System.IO.DirectoryInfo)">
            <summary>
            Remove the read-only attribute from all files.
            </summary>
            <remarks>
            Adapted from: https://stackoverflow.com/questions/1982209/cannot-programatically-delete-svn-working-copy
            </remarks>
        </member>
        <member name="T:R5T.F0000.IGuidOperator">
            <summary>
            
            </summary>
            <remarks>
            Prior work:
            * R5T.B0000.IGuidOperator
            * R5T.T0055.IGuidOperator
            * R5T.D0004.IGuidProvider
            </remarks>
        </member>
        <member name="M:R5T.F0000.IGuidOperator.New(System.Random)">
            <summary>
            Returns a new Guid use the specified random (for seeded Guids, useful in testing).
            </summary>
            <remarks>
            Source: https://stackoverflow.com/a/13188409/10658484
            </remarks>
        </member>
        <member name="M:R5T.F0000.IGuidOperator.ToString_B_Format(System.Guid)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Documentation.ForGuid.B_Format"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.IGuidOperator.ToString_B_Uppercase_Format(System.Guid)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Documentation.ForGuid.B_Uppercase_Format"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.IGuidOperator.ToString_D_Format(System.Guid)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Documentation.ForGuid.D_Format"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.IGuidOperator.ToString_D_Uppercase_Format(System.Guid)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Documentation.ForGuid.D_Uppercase_Format"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.IGuidOperator.ToString_N_Format(System.Guid)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Documentation.ForGuid.N_Format"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.IGuidOperator.ToString_P_Format(System.Guid)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Documentation.ForGuid.P_Format"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.IGuidOperator.ToString_X_Format(System.Guid)">
            <summary>
            <inheritdoc cref="F:R5T.Y0000.Documentation.ForGuid.X_Format"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.IGuidOperator.ToString_Standard(System.Guid)">
            <summary>
            <para>The standard format is default (D uppercase) format.</para>
            <inheritdoc cref="F:R5T.Y0000.Documentation.ForGuid.D_Uppercase_Format"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.IGuidOperator.ToString(System.Guid)">
            <summary>
            <para>The default is the D format.</para>
            <inheritdoc cref="F:R5T.Y0000.Documentation.ForGuid.D_Format"/>
            </summary>
        </member>
        <member name="M:R5T.F0000.IIndexOperator.GetLastExclusiveIndex(System.Int32)">
            <summary>
            Gets the last <inheritdoc cref="F:R5T.Y0000.Glossary.ForIndex.Exclusive" path="/name"/> index from a last <inheritdoc cref="F:R5T.Y0000.Glossary.ForIndex.Inclusive" path="/name"/> index by adding one.
            <para><inheritdoc cref="F:R5T.Y0000.Glossary.ForIndex.ExclusiveInclusiveRelationship" path="/definition"/></para>
            </summary>
        </member>
        <member name="M:R5T.F0000.ISourceCodeOperator.GetCurrentSourceCodeFilePath(System.String)">
            <summary>
            Gets the file path of the source code file in which this method is called.
            </summary>
        </member>
        <member name="M:R5T.F0000.IStringOperator.GetHashCode_NonDeterministic(System.String)">
            <summary>
            The default <see cref="M:System.String.GetHashCode"/> is non-deterministic.
            This method just calls that method.
            </summary>
        </member>
        <member name="M:R5T.F0000.IStringOperator.GetHashCode_Deterministic(System.String)">
            <summary>
            The default <see cref="M:System.String.GetHashCode"/> is non-deterministic.
            This method provides a deterministic implementation.
            </summary>
            <remarks>
            Source: https://andrewlock.net/why-is-string-gethashcode-different-each-time-i-run-my-program-in-net-core/#a-deterministic-gethashcode-implementation
            </remarks>
        </member>
    </members>
</doc>
